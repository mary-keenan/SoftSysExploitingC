#include <stdio.h>

int test_pw() {
        char pin[10]; /* reserve space for password */
        int x=15, i;
        printf("Enter password: ");
        gets(pin); /* get user input with no bounds-checking */
        for (i=0; i<10; i+=2) x = (x & pin[i]) | pin[i+1]; /* do some basic password scrambling */
        if (x == 48) return 0;
        else return 1;
}

void main() {
        if (test_pw()) printf("Fail!\n");
        else printf("You win!\n");
}

/* 

NOTE: I WAS RUNNING ALL OF THIS IN A 32-BIT KALI LINUX VM

I debugged the program with gdb and added break points at lines 7 and 9.
At line 7, the three relevant registers (eip, esp -- top of stack frame, 
and ebp -- bottom of stack frame) had the values:

$eip = 0x8440156 <test_pw+29> (it's inside the test_pw function)
$esp = 0xbffff340
$ebp = 0xbffff368

The function return address is 0x084401c8.

When I enter AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTT as the password and
break at line 9, I see that the return address has been overwritten; it's
now 0x51515050, which is hexadecimal for "PPQQ" in reverse order.

When I continue running the program after the breakpoint at line 9, it
fails with a segmentation fault because the eip now contains 0x51515050.

If I execute disassemble main in gdb, I find that the address of the
second "puts" command (mov) is 0x084401ef <+61>. This is the "You win!"
branch of the conditional statement, so if I make it the return address
from test_pw(), I can circumvent the password check. 

*/