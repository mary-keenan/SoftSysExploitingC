#include <string.h>
#include <stdio.h>

void main(int argc, char *argv[]) {
	copier(argv[1]);
	printf("Done!\n");
}

int copier(char *str) {
	char buffer[100];
	strcpy(buffer, str);
}

/* 

NOTE: I WAS RUNNING ALL OF THIS IN A 32-BIT KALI LINUX VM

This program copies a string into a buffer without checking the
size of the string. The overflow can't happen in main() since it
has a special stack format that can't be broken by this attack.

Executing "gcc -g -z execstack -no-pie -o 
project_3_buffer_overflow_w_shellcode.c" compiles the code without
modern stack overflow protections.

You can then cause a segfault by inputting 116 A's.

If I break at line 12, I can see that the registers esp and ebp
have the values 0xbffff3b0 and 0xbffff428, respectively.
0x0804919f is the return address of the instruction to be called
after main() returns.

When I input 116 A's, the return address becomes 0x41414141. I
can see in the gdb console that the last four bytes of my 116 A's
take up the return address' spot, so if I put my desired return
address in the last four bytes of my string (112 A's plus the 
return address, backwards), I can redirect the program to my code
after it exits from main().

The shellcode I'm injecting (shown below) spawns a "dash" shell. 

\x31\xc0\x89\xc3\xb0\x17\xcd\x80\x31\xd2\x52\x68\x6e\x2f\x73\x68
\x68\x2f\x2f\x62\x69\x89\xe3\x52\x53\x89\xe1\x8d\x42\x0b\xcd\x80

I put the shellcode in a python file with 64 NOPs ('\x90')
preceding it to increase my chance of hitting it; then I fill
the space between the shellcode and return address with random
characters (just A's for now). I put an address somewhere in 
the middle of the NOP sled at the end of the injected code, where
the return address is for main(). In my case, the desired
return address was '\x70\xf2\xff\xbf'.

When I run it in gdb, my exploit opens a shell.

*/