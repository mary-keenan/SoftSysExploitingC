# Lecture 2 of CNIT 127: Exploit Development
Located [here](https://www.youtube.com/watch?time_continue=1&v=VfzrfomAenQ).

## Stack-Based Buffer Overflows
- (most of the lecture content is on using gdb)
- They were the original exploitation method and the most popular until around 2008, when Microsoft put in measures to prevent it. It went from being ised in 80% of attacks to being used in 5-10%. As of 2012-14 ish, the most popular attack is dangling pointers.
- C handles each statement in an isolated manner, which means it often doesn't have any bounds checking. If you have a five-element array and you try to access the sixth element, C won't remember or check the size of the array.
- Most crashes are non-exploitable; they stop a server but don't allow for remote code execution.
- The goal is get your code into registers, ideally EIP.
- The AT&T format is more popular with Linux users while the Intel format is more common with Windows users.
- The stack's primary purpose is to make functions more efficient. When a function is called, the calling routine temporarily stops processing its instructions and transfers control to the function (or subroutine). The state of the calling routine is saved to the stack and the new subroutine is given its own stack frame.
- When a prolog executes, it pushes EBP onto the stack, copies ESP into EBP (to save the current state of the program), and allocates a sufficient amount of room for the subroutine in a stack frame. Once the subroutine finishes, the memory is freed; memory leaks occur when dynamically-allocated memory isn't freed during the subroutine, because it can't be freed after the subroutine finishes.
- The simplest exploits don't add code; they change the way the existing victim code runs. For example, you could get main() to skip a few lines, perhaps an authentication step, and use that to exploit the system somehow.
- Typically, in order to take control of a system, you need to inject code and change the return address of a function to point at that code. Stack overflows allow you to do both at the same time, because you can overflow the buffer using your own code with a return address affixed at the end that points to the beginning of the buffer. This only works when the stack is big enough to store injected code; you generally need at least 50 bytes (preferably 300) for attacks but you can still change passwords or add administrators when you have 30-40 bytes of space to work with.