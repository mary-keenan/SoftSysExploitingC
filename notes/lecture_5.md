# Lecture 5 of CNIT 127: Exploit Development
Located [here](https://www.youtube.com/watch?v=VhwNPdqpmts&feature=youtu.be).

## Heap Overflows
- The simplest heap overflows are simpler than buffer overflows, although the idea is very similar (overflow a variable to change the value of another variable).
- Each chunk of memory in the heap points to the next and last chunk (doubly-linked list). Moving from chunk to chunk is called "walking the heap".
- Every few seconds, Cisco routers walk the heap to make sure everything is the way it should be; if the heap overflows, the pointers to the neighbor heap sections will get overwritten and you won't be able to walk the heap. If the Cisco router finds a broken heap, it will dump the package and reboot (it doesn't do error handling).
- Heap overflows do not normally give you access to the EIP (because it's stored on the stack). However, the heap does have addresses it uses for writes (to fill in heap data, rearrange chunks when free() is called so they skip over the removed heap section, etc). 
- To use a heap overflow to take over a machine, you need to write to some piece of memory that will be used as an address later (these target RAM options are the same as they are for the stack -- return addresses on the stack, global offset table that directs you to shared library functions, destructors tables, C library hooks, function pointers, exception handlers, etc).
- The %n format string writes the characters printed so far to RAM; this can be used for format string exploits. The lecturer doesn't know what purpose %n serves other than for exploits, so it's kind of strange.
- 0xcc will stop a program immediately, so it should never be included in an exploit (unless you want to quickly check if the area you're exploiting is executable, in which case you can fill it with 0xcc and see if it breaks).
- 0x00 terminates a string, which breaks shellcode, so it should never be included in exploits.