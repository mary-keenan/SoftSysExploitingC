# Lecture 1 of CNIT 127: Exploit Development
Located [here](https://youtu.be/t41oSWQvWBM)

## Class Prerequisites
- You're expected to have a good understanding of computer security and networking (TCP/IP, firewalls, malware, etc).
- It is supposedly pointless to do this class without the textbook (The Shellcoder's Handbook).

## Overview of the Field
- The simplest attacks are denial-of-service (DOS) attacks, which just crash a server, but they're not very useful since you don't gain control of anything.
- Exploit development build on DOS attacks to gain control; for example, they don't just try to create buffer overflows, they try to create specific buffer overflows (with specific characters, etc) that influence the system.
- Windows has a lot of defenses because Microsoft is very proactive about preventing hacks (by hiring hackers, etc), whereas Linux is not (and it's hacked a lot).
- A vulnerability is a flaw in the system that allows an attacker to do something unexpected (ie DOS, elevating privileges, or remote code execution).
- A 0Day is an exploit that no one knows about (so people aren't protected against) -- they're worth a lot to the vulnerable companies, and are often sold to them or to the military
- There are two ways to identify vulnerabilities: by reading the code (if it's open source or internal to the company) or by a blackbox attack where you just send a bunch of random data to the process to get it to crash and then try to see if you can build on that crash.
- Most vulnerabilities can only be used to crash a server; only a small % of them can be used to gain control.
- There is no intrinsic difference between data and executable instructions -- they're all just bytes, so you can confuse the computer (for example, since GIFs have headers but not footers and Java JAR files have footers but not headers, people were able to get sites that upload photos to run Java code by creating a GIF-Java file labelled as a JAR file).

## Memory
- There are three segments in a program's address space: .text (program instructions, read-only), .data (initialized global variables), and .bss (uninitialized global variables).
- The stack is LIFO (it grows down in address space) and ideal for storing transitory information. A stack overflow is the easiest kind of exploit, and other types of attacks generally build on it. Today, modern OS is defended against stack overflows. 
- The most common kind of overflow is to get control of the extended instruction pointer and point it to code you have control over.
- The heap is FIFO (it grows up in address space) and ideal for temporarily storing data.

## Assembly
- Assembly language is intended to be human-readable (machine language is not), but it's still difficult.
- Most malware is designed for the x86 (32-bit Intel) processor, but the increasingly popular x64 (64-bit Intel) processor can run x86 programs.
- Everything is moving to x64 except the IoT, which are sticking with 32-bits in order to be small and cheap; however, IoT devices are already super easy to hack.
- Assembly instructions start with a mnemonic followed by operands; for example, "mov ecx 0x42" means "move into Extended C register value 42". In binary, this instruction would be 0xB942000000, where "mov ecx" is 0xB9 in hexadecimal.
- Network data uses big-endian (most significant byte first, like 0x00000042) whereas x86 programs use little-endian (least significant byte last, like 0x42000000). For example, an IP address of 127.0.0.1 (7F 00 00 01 in hex) is sent over the network as 0x7F000001 but stored in RAM as 0x01000007F.
- There are three types of operands: immediate (fixed values like 0x42), registers (ie ecx), and memory addresses (denoted with brackets, like [eax]).
- Registers are generally 32-bit, but the eax, ebx, ecx, and edx registers can also be referenced as 8-bit (or 16-bit) values.
- General registers normally store data or memory addresses and are interchangeable, but some instructions reference specific registers (ie multiplication and division use eax and edx).
- Generally, compilers follow certain conventions in using registers (ie eax contains the return value for function calls).
- eflags is a status register with 32-bits that each represent a different flag (on/off).
- eip (the instruction pointer) contains the memory address of the next instruction to be executed; if it contains the wrong data, the CPU will get illegitmate instructions and crash.
