# Lecture 1 of CNIT 127: Exploit Development
Part 1 is located [here](https://youtu.be/t41oSWQvWBM).
Part 2 is located [here](https://www.youtube.com/watch?v=y1Pv2WvYgzA&feature=youtu.be).

## Class Prerequisites
- You're expected to have a good understanding of computer security and networking (TCP/IP, firewalls, malware, etc).
- It is supposedly pointless to do this class without the textbook (The Shellcoder's Handbook).

## Overview of the Field
- The simplest attacks are denial-of-service (DOS) attacks, which just crash a server, but they're not very useful since you don't gain control of anything.
- Exploit development build on DOS attacks to gain control; for example, they don't just try to create buffer overflows, they try to create specific buffer overflows (with specific characters, etc) that influence the system.
- Windows has a lot of defenses because Microsoft is very proactive about preventing hacks (by hiring hackers, etc), whereas Linux is not (and it's hacked a lot).
- A vulnerability is a flaw in the system that allows an attacker to do something unexpected (ie DOS, elevating privileges, or remote code execution).
- A 0Day is an exploit that no one knows about (so people aren't protected against) -- they're worth a lot to the vulnerable companies, and are often sold to them or to the military
- There are two ways to identify vulnerabilities: by reading the code (if it's open source or internal to the company) or by a blackbox attack where you just send a bunch of random data to the process to get it to crash and then try to see if you can build on that crash.
- Most vulnerabilities can only be used to crash a server; only a small % of them can be used to gain control.
- There is no intrinsic difference between data and executable instructions -- they're all just bytes, so you can confuse the computer (for example, since GIFs have headers but not footers and Java JAR files have footers but not headers, people were able to get sites that upload photos to run Java code by creating a GIF-Java file labelled as a JAR file).

## Memory
- There are three segments in a program's address space: .text (program instructions, read-only), .data (initialized global variables), and .bss (uninitialized global variables).
- The stack is LIFO (it grows down in address space) and ideal for storing transitory information. A stack overflow is the easiest kind of exploit, and other types of attacks generally build on it. Today, modern OS is defended against stack overflows. 
- The most common kind of overflow is to get control of the extended instruction pointer and point it to code you have control over.
- The heap is FIFO (it grows up in address space) and ideal for temporarily storing data.

## Assembly
- Assembly language is intended to be human-readable (machine language is not), but it's still difficult.
- Most malware is designed for the x86 (32-bit Intel) processor, but the increasingly popular x64 (64-bit Intel) processor can run x86 programs.
- Everything is moving to x64 except the IoT, which are sticking with 32-bits in order to be small and cheap; however, IoT devices are already super easy to hack.
- Assembly instructions start with a mnemonic followed by operands; for example, "mov ecx 0x42" means "move into Extended C register value 42". In binary, this instruction would be 0xB942000000, where "mov ecx" is 0xB9 in hexadecimal.
- Network data uses big-endian (most significant byte first, like 0x00000042) whereas x86 programs use little-endian (least significant byte last, like 0x42000000). For example, an IP address of 127.0.0.1 (7F 00 00 01 in hex) is sent over the network as 0x7F000001 but stored in RAM as 0x01000007F.
- There are three types of operands: immediate (fixed values like 0x42), registers (ie ecx), and memory addresses (denoted with brackets, like [eax]).
- Registers are generally 32-bit, but the eax, ebx, ecx, and edx registers can also be referenced as 8-bit (or 16-bit) values.
- General registers normally store data or memory addresses and are interchangeable, but some instructions reference specific registers (ie multiplication and division use eax and edx).
- Generally, compilers follow certain conventions in using registers (ie eax contains the return value for function calls).
- eflags is a status register with 32-bits that each represent a different flag (on/off).
- eip (the instruction pointer) contains the memory address of the next instruction to be executed; if it contains the wrong data, the CPU will get illegitmate instructions and crash.

## Jasmin
- The "memory" shown in Jasmin is RAM. That's where the stack is stored.
- "mov register, value" places a value in a register
- "mov [register], value" places a value in memory at the address that equals the value stored in that register.
- "push register" puts the register's value at the top of the stack (which is at the end of the address space).
- "pop register" removes whatever is on top of the stack and places it into the register.
- The value that was popped stays on the stack (it's not cleared) but the stack pointer (esp) increases, so the next value that gets pushed will replace the popped value in the stack.

## Simple Instructions
- The (Intel) format favored by Windows developers is "instruction destination, source" (like I used in the last section); there's another format type (AT&T) that's less common.
- The mathematical operator instructions are sub, add, inc, dec, mul, and div. They should be pretty self-explanatory.
- **nop is an instruction that does nothing** (it literally gets skipped over), **but it makes it easier for attackers to run code**. Attackers use things like input fields to insert their own code into the existing code, but in order to run their code, they have to guess its location (and then point at it). By putting hundreds of NOPs before their own code, attackers increase their chances of successfully guessing its location (ex. you're more likely to guess correctly for "benign skip skip skip attack benign" than "benign attack benign", because you have a wider margin for error). This is called a **NOP Sled**.
- esp is the extended stack pointer; it points to the top of the stack.
- ebp is the extended base pointer; it points to the bottom of the stack.
- When you make a simple function call, like printf(), a prologue (set of instructions) saves the current state before entering the function and an epilogue restores the saved state.
- The code snippets below show an example piece of C code is represented in assembly code.

In C:
```c
int number;
...
number++;
```

In assembly code:
```assembly
number dw 0 ;dw means define word
...
mov eax, number
inc eax
mov number, eax
```

- Arrays are defined with the array keyword; for example, "int array[4]"" is "array dw 0,0,0,0".
- When doing malware analysis, you need to give up the idea of understanding everything. There's always too much information to process, so you should skim code and look for things of interest, then go from there.

