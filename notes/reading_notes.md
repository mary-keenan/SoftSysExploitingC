# Notes from the Purdue Readings
The list of readings can be found [here](https://www.cs.purdue.edu/homes/clg/CS526/). All of the available readings are in the purdue_readings/ folder in this repository.

## Introduction, Threat Modeling
All three readings are very short. The first one has an interesting punchline, but it takes some time to get there. The second article is a little funny, but the third was not particularly useful.

### Reflections on Trusting Trust
- The C compiler is written in C...magic.
- The moral is that you can't trust code you did not write. The author demonstrated how he could create a bug in the C compiler that would allow him to login as any user in a program compiled with his bugged compiler -- without leaving any trace in the source code.
- The lower the program level, the harder it is to detect bugs.
- The author is advocating that breaking into computer systems should have the same penalties as analogous crimes, like breaking into a building, but he believes there's a cultural gap where people don't yet see them as analogous cases.

### The Security Mindset
- Security professionals can't help but constantly look for vulnerabilities and ways to exploit them.
- It's harder to teach someone to think a certain way than it is to teach them content (although there are professors trying), but it's useful for everyone to think with a security mindset.

### How to Think Like a Security Professional
- Security knowledge may go out-of-date, but the mindset won't.

## Software Security
Only two of the four readings are accessible. They are relatively long but extremely informative. 

### Smashing the Stack for Fun and Profit
- Code that writes past the end of an array declared auto "smashes the stack."
- Processes are divided into three regions: Text (instructions, read-only), Data (initialized and uninitialized variables), and Stack. 
- Logical stack frames make up the stack; each frame contains the information for a function that has been called -- its local variables, parameters, and the data necessary to get back to the last stack frame (such as the EIP at the time of the function call).
- The prologue stores the current state of the program (and memory), prior to a new function call; the epilogue restores the program back to this state.
- Buffer overflows make it possible to change the return address of a function; you just need to determine where the return address is in relation to the buffer, make a pointer to that location, and change the value. What value you insert depends on what instruction you want to jump to in the assembly code. 
- **To exploit a buffer overflow, you place code into the buffer (that creates a shell) and overwrite the return address to point back into the buffer**.
- The first few lines in assembly code ("push ebp", etc) for each function are the prologue; they save the current state. The last few lines are the epilogue; they return the program to the prior state.
- Since you don't know where in the adddress space your code will be placed, you can use the "call" and "jmp" instructions to take advantage of relative addressing.
- Since the text segment is marked read-only and the exploit code modifies itself, it needs to be placed in the stack or data segments (in a global array, for example).
- Guessing the buffer offset is extremely difficult, so NOP instructions (mentioned in Lecture 1 Part 2) are used to pad the front of the overflow buffer and make it easier to find. 
- The buffer size should be around 100 bytes more than the buffer you're trying to overflow to leave room for a lot of NOPs while still allow you to overwrite the return address.
- Buffers can be too small to contain the shellcode (it runs into the return address) or a sufficient number of NOPs. If you have access to the program's environment variables, you can put shellcode into an environment variable and then just overflow the buffer with the address of the variable. Environment variables are stored at the top of the stack when the program starts but allocated elsewhere when changes are made. 
- gets(), getc(), fgetc(), getchar(), scanf(), strcat(), strcpy(), sprintf(), and vsprintf() are all functions that have no built-in boundary checking and can thus be exploited.

### Basic Integer Overflows
- Integers (like all variables) are just regions in memory. If you put more information (a number that's bigger than the max representable number) in an integer than it can store, it will overflow, which leads to undefined behavior.
- Integer overflows cannot be detected after the fact; if an integer overflow changes the value of a variable the program is going to use later, there is no way for the program to know that variable has an incorrect value.
- Typically, when a number is too big to store, the modulus of the number is stored instead, using the highest storable number plus one as the modulus. This truncates the value.
- Integer promotion is the act of temporarily increasing the size of a variable to equal the size of a larger variable. For example, if a is 8 bits and b is 32 bits and you do a = a * b, a is temporarily allocated 32 bits of memory for the operation. Afterwards, the result is truncated so it can be stored in a.
- Integer overflows (and underflows) are necessary for a lot of signed arithmetic because the values can wrap from negative to positive; as a result, overflows can often cause unintended changes in sign.
- You can take advantage of integer overflows by giving a program a certain large number that, when operated on, will wrap around and become a lower number; this lower number may pass a bounds check ((len * 5) < 80) and then be used to create a buffer overflow (memcpy(dest, input, len)) later in the code.
- When signed integers are interpreted as unsigned, they tend to be huge. The highest possible 32-bit integer value is 4,294,967,295; if -1 is interpreted as unsign, it becomes the highest value.
- Integer overflows are less of an exploitable vulnerability and more of a reliability concern; they cause undefined behavior, and that's bad.
- The moral of the story? Be smart about checking bounds so you don't let a signed integer slip through as unsigned, etc. 


## Malware
Both of these readings are optional. The one about the internet worm is entertaining; it was written in 1988, so more information about the Morris Worm (as it's now called) is available if you're interested.

### A Report on the Internet Worm
- A virus is a piece of code that adds itself to a program and runs only when that program is run by the host (which is analogous to real life viruses).
- A worm is a program that can run and duplicate itself.
- In 1988, a student created a worm that sought only to replicate itself and spread; he intended it to be an experiment, but it became a real problem.
- The worm had three methods of attacking; the one that was most successful targeted the finger daemon (fingerd), which didn't limit the number of arguments it read from a pipe and could thus be used to create a stack overflow.
- Another attack method tried to guess passwords to gain control of users' accounts. The worm tried combinations of the username, first, last, last+first, nick names, "popular" passwords (created by the attacker; it included funny passwords like "spit" and "larry"), and, if all else failed, every word in the dictionary. It did a pretty good job of figuring out passwords.
- The worm was difficult to track; it ran without a name (so the "ps" command didn't reveal anything), deleted its files as soon as it opened them, etc. It replicated itself via forks, sending children version to attack new hosts. Once every 15 worms, a message was sent to a Berkeley address (the attacker was a Cornell student who launched the worm at MIT).
- Fun note: Students at Berkeley, MIT, and Purdue obtained the source code and created source patches for bugs in the code, just because they thought it was funny. 
- Morris, the attacker, was charged with the 1st felony conviction under a new computer fraud and security law. His worm was only dangerous in that it replicated so aggressively that a single host could be simultaneously attacked by enough forks that it slows to the point of being inoperable. 
- Morris ended up teaching at MIT.
