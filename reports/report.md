# Exploiting C Report
By Mary Keenan

## Project Goal
The goal of this project was to learn about exploit development in C, which is the process of identifying vulnerabilities in programs and exploiting them to obtain information, influence the program, or take control of the operating system. I accomplished my goal by loosely following the curriculum of two classes: City College’s Exploit Development course and Purdue’s Information Security course (both described in the Resources section below). I learned about C vulnerabilities and exploits by watching lectures 1-5 and completing projects 0-4 in the City College class. These lectures and projects are supposed to be completed in the first month of the class, so that aligned well with the one-month timeframe of this project. I also did most of the readings assigned in the first month of the Purdue class to learn more about cyber security in general. I had hoped to attempt Project 1 in the Purdue class, but I unfortunately did not get that far. Since the goal of this project was to learn about a new topic and not to make something, I do not have a final product to show for my work, but I do have a collection of notes from the projects (where I practiced simple exploits), lectures, and readings in this repository that show I gained a basic foundation in exploit development.

## Resources
There are two classes with online resources I used for this project: [City College of San Francisco’s Exploit Development course](https://samsclass.info/127/127_S17.shtml) and [Purdue’s Information Security course](https://www.cs.purdue.edu/homes/clg/CS526/). I chose to follow these classes because they made their learning materials easily available. The City College course has everything online -- the lectures, readings, projects, etc -- while the Purdue class published its readings and projects. The City College projects are relatively short and have step-by-step instructions while the Purdue projects are more open-ended and difficult. Both classes were recently published (2017 and 2018), so their material should be up-to-date. Altogether, I decided that these two classes would give me a detailed but varied overview of exploit development.

In addition to its assigned readings, the Purdue course also has four larger, less-guided projects listed on its website; the [first project](https://www.cs.purdue.edu/homes/clg/CS526/projects/project1.pdf) is supposed to be completed by the end of the first month, but I did not have time to try it. The City College course projects are very structured, so I did not find it necessary to do any outside research to complete them. If I had attempted the less structured and more advanced Purdue projects, I probably would have needed to use other resources. For posterity’s sake, I am including some additional resources I found prior to starting this project. I did not end up needing them, but they could be useful to others interested in doing a similar project. 
[Former SoftSys project](https://github.com/SelinaWang/SoftSysSiz)
Blog posts by Dhaval Kapil (https://dhavalkapil.com/blogs/Buffer-Overflow-Exploit/, https://dhavalkapil.com/blogs/Shellcode-Injection/, and https://dhavalkapil.com/blogs/FILE-Structure-Exploitation/) as well as the book he wrote called [Heap Exploitation](https://heap-exploitation.dhavalkapil.com/attacks/). 
[Stanford Computer and Network Security course](https://crypto.stanford.edu/cs155old/cs155-spring18/) (includes pdfs of lectures, readings, homeworks, and projects)

## Results
I successfully completed the first month of coursework for the City College class. The [notes folder](https://github.com/mary-keenan/SoftSysExploitingC/tree/master/notes) in this repository contains the notes for each of the five lectures I watched, and the [code folder](https://github.com/mary-keenan/SoftSysExploitingC/tree/master/code) contains code and notes for each of the five projects I completed. While doing the first five City College projects, I played around with assembly code to understand it better, practiced a simple buffer overflow attack to list the contents of my working directory, and injected shellcode to spawn a shell, to name a few activities. 

Projects 2-4 were done on a 32-bit Kali Linux VM, as recommended by the City College instructor, and since it was inconvenient to copy files between my machine and the VM, I did not include all of the code or its iterations from those projects in this repository. I included the victim code for projects 2 and 3 and the final attack code for project 4. Each code file, however, includes project notes that describe the overall process of developing the exploit, which should fill in any gaps. 

The City College projects I completed all covered buffer overflows, which have historically been the most common exploit. [Project 1](https://samsclass.info/127/proj/p1-lbci.htm) best summed up the basics of the attack. The vulnerable program in project 1 prompts the user to enter their name without limiting the size of the input and then copies that name into a smaller buffer, again without any checks. The code for this program is included below.

```c
#include <string.h>
#include <stdio.h>

main(){
        char name[200];
        printf("What is your name?\n");
        scanf("%s", name); /* there is no limit to the input */
        bo(name, "uname -a");
}

int bo(char *name, char *cmd){
        char c[40];
        char buffer[40]; /* overflows when >40 characters are entered */
        printf("Name buffer address:    %x\n", buffer);
        printf("Command buffer address: %x\n", c);
        strcpy(c, cmd); 
        strcpy(buffer, name); /* the inputted name is copied to the smaller buffer */
        printf("Goodbye, %s!\n", buffer);
        printf("Executing command: %s\n", c);
        fflush(stdout);
        system(c); /* executes the command in buffer c */
}
```

When the user enters a name, it’s placed in the `name[200]` buffer. Any input that is less than 200 characters long will fit; however, the input is then copied into a buffer, `buffer[40]`, that is only 40 characters long. If the user’s input is greater than 40 characters, it will overflow `buffer[40]` in function `bo()`. Since the stack builds up and `buffer[40]` was declared after `c[40]` in function `bo()`, the overflow from `buffer[40]` will first run into `c[40]`. The command in `c[40]` gets executed at the end of the program, so if the buffer `c[40]` gets overwritten, whatever command was written in it will get executed. So, theoretically, if the user enters 40 A’s and `ls` (“AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAls”), the program will print the contents of the program’s working directory. When I completed this project, I found that despite the 40-character size of `buffer`, it took 50 characters to reach the `c` buffer. So, I added an additional 9 A’s before the `ls`. The result was the contents of my [code folder](https://github.com/mary-keenan/SoftSysExploitingC/tree/master/code).

```shell
(base) mary:code$ ./exe_project_1_command_injection 
What is your name?
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAls
Name buffer address:    52086ae0
Command buffer address: 52086b10
Goodbye, AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAls!
Executing command: ls
exe_project_1_command_injection  project_2_buffer_overflow_wo_shellcode.c
msfinstall			 project_3_buffer_overflow_w_shellcode.c
project_0_jasmin_intro.asm	 project_4_remote_buffer_overflow_w_listening_shell.py
project_1_command_injection.c
(base) mary:code$ 
```

Other commands less than 40 characters long could be entered after the 49 A’s as well, but this example is intentionally simple to demonstrate the basics of buffer overflows. The target that gets overwritten in a buffer overflow can be a number of things, another variable or the return address of the function (the latter of which is the target in the subsequent City College projects). The point of exploit development is generally to obtain information, influence programs, or take control of operating systems. This particular exploit forces the program to disclose information (the working directory contents).

In addition to the City College coursework, I also finished most of the readings assigned in the first month of the Purdue class. I read the three “Introduction, Threat Modeling” readings, the two available “Software Security” readings, the required “Intro to Networking, TCP/IP” reading, and one of the “Malware” readings. These readings span four of the six topics I had hoped to get through. Through them, I learned about the history of exploit development (the Internet Worm reading was particularly entertaining!), the mindset and tools of security professionals, and the most basic forms of attack (overflows, buffer and integer). 

All of the available readings for the first month of the course (both required and optional) are in the [readings folder](https://github.com/mary-keenan/SoftSysExploitingC/tree/master/purdue_readings) of this repository to make it easy for people to track them down should they be interested in doing something similar in the future. 

## Reflection
My goal when I began this project was simply to learn about common security vulnerabilities in C programs and how to exploit them. I had no prior knowledge in this area, and I was not aspiring to become an expert over the course of this month-long project; I was hoping to build a basic foundation. I do think I accomplished that goal. I now have experience exploiting buffer overflows on the stack and the theoretical knowledge of how to do so on the heap. I have learned how to use formatted strings to my advantage and that, while integer overflows are often un-exploitable, they are still problematic and tricky to track down (Can you imagine anything worse than accidentally treating a signed integer as unsigned in a bounds check? Read “Basic Integer Overflows” if that made no sense!). Through the Purdue readings, I was also able to get a small peek into the mind of security professionals and their culture, something I had not expected to be particularly interesting; the “A Report on the Internet Worm” reading proved otherwise. 

While I accomplished my personal goals, I did not get as far in this project as I had hoped I would. I wanted to attempt the first project in the Purdue course, because it was intriguingly open-ended, and I thought it would be the perfect way to test my understanding of basic security concepts. However, the City College projects and lectures and the Purdue readings took longer to get through than I expected, and I did not end up having enough time to finish all of the Purdue readings or test my skills against any of the Purdue projects. If I were to do this project again, I would probably skip projects 3 and 4 in the City College course and do fewer Purdue readings. Then, I would hopefully have enough time to work on the first Purdue project, although I am not sure if I would be able to finish it successfully; it does not look like it would match up well with what I learned in the City College course. But, it would be fun to try it!

